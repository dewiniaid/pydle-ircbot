import collections
import inspect
import re

from .exc import *
import logging
logger = logging.getLogger(__name__)


__all__ = ['Binding', 'register_type', 'Parameter', 'ParamType', 'StrParamType', 'ConstParamType', 'NumberParamType']


_default = object()


class Binding:
    """
    A given IRC command can have one or more bindings.
    A binding consists of:
    - A function to call
    - A priority (default 0)
    - A parameter string, consisting of a a space-separated list of variables, constants, and options

    If the first word of a line of text matches one of the command names, the remainder is checked against the bindings
    available for that command in order of priority.  (Bindings with the same priority are called in the order they
    were defined).

    The first binding that is matched calls its function with arguments set corresponding to contents of the
    parameter string.

    Approximate ABNF syntax for parameter strings:

    ::

        SPACE = 1*(WSP / CR / LF)

        param-string = param *(SPACE param)
        param = (*"[" (variable | constant) *"]") / option

        word = 1*(ALPHA / DIGIT)
        name = 1*WORD
        type = 1*WORD
        help = 1*WORD
        type-specifier = ":" type
        help-specifier = "?" [help]
        const-phrase-separator = "/" / "|"
        const-phrase = WORD 1*(const-separator WORD)
        constant = bare-constant / parenthesized-constant
        bare-constant = [name "="] const-phrase [help-specifier]
        parenthesized-constant = "(" bare-constant ")"

        variable = "<" name [type-specifier] [help-specifier] ">"

        option = "/" 1*ALPHA

    **Constants:**

    Constants are optionally wrapped in parenthesis.  They consist of the following, in order:
    - An optional argument name, followed by an equals sign, which will receive a lowercased version of the constant.
    - One or more words, separated by the | or / characters.  Text has to be a (case-insensitive) match to one of the
    listed words.
    - An optional helpname, consisting of a question mark (?) followed by text that should be used in place of the
    variable name in help.  This may contain spaces as long as the constant is wrapped in parenthesis.

    Examples:

    ``foo``
        Word must exactly match 'foo'
    ``action=add|delete``
        Word must be 'add' or 'delete', and the function's 'action' argument will match the word.
    ``(action=add|delete?ACTION)``
        As above, but will show as ACTION in helptext.

    When a constant is present, parsing expects an exact (case-insensitive) match to one of the words listed:

    ``foo``
        Word must be 'foo'
    ``foo|bar or foo/bar``
        Word must be 'foo' or 'bar'

    A constant may be optionally preceded with "name=".  If so, the parameter named *name* will be set to the constant
    value when calling the function.

    **Variables:**

    Variables are wrapped in angle brackets and normally correspond 1-to-1 with words in the text being processed.
    They consist of the following, in order:

    - A name, which must match the name of a function argument (unless the function has `kwargs`)
    - An optional type specifier, consisting of a colon (:) plus the name of a type.  Currently supported types are:
      - ``:line`` - Matches the rest of the line instead of the usual one word.  Should be the last parameter.
      - ``:str`` - Input coerced to string.  This is the default.
      - ``:int`` - Input coerced to integer.
    - An optional helpname, consisting of a question mark (?) followed by text that should be used in place of the
      variable name in help.  This may contain spaces.

    The variable name may also be preceded by one of the following:

    ``*``
        Produces a list of 0..*N* items.  Must be the last parameter.
    ``+``
        Produces a list of 1..*N* items.  Must be the last parameter.
    ``?``
        Optional variable.  The function's default value will be used if the variable is not present.

    **Options:**

    Options begin with a "/", and the remaining text sets various options.

    The only current option is:

    u
        If present and all bindings raise a UsageError, use this one's exception rather than the first UsageError
        raised.  If this is present on more than one binding, the last one to execute is used.

    Optional parameters:
    Each chunk may optionally begin with any number of ['s and end with any number of ]'s to indicate that they are
    optional.  Note that this only affects the help text.

    :ivar label: Our label
    :ivar function: The function that we're bound to.
    :ivar signature: A `class:inspect.Signature` from the bound function
    :ivar usage: Usage helptext generated by parameters.
    :ivar params: Parameters.
    :ivar summary: Short summary of usage.
    :ivar is_default_error: True if /u is set.
    :ivar command: Command that we're linked to.
    :ivar minargs: Minimum number of arguments we handle.
    :ivar maxargs: Maximum number of arguments we handle.
    """
    _paramstring_symbols = '[^<>()]'

    # Each group is named with 'prefix_name[_unused]
    # Prefix is used for classification.  Name is used for variable naming.  Unused exists solely as a way to avoid
    # duplicate parameter names.
    _paramstring_re = re.compile(
        r'''
        (?:
            # Options
            (?:/(?P<options>))
            # Or constant/variable
            | (?:
                (?P<prefix_0>\[*)                   # Allow any number of brackets to indicate optional sections
                (?:
                    # Parameter
                    (?:(?P<prefix_1>\<)                 # begin
                        (?P<var_count>[+*?])?           # argument count.
                        (?P<var_arg>%N+?)               # argument name
                        (?:\:(?P<var_type>%N+?))?       # optional type specifier
                        (?:\:(?P<var_options>%N+?))?    # optional type specifier
                        (?:\?(?P<var_name>%N+?))?       # optional helptext
                    (?P<suffix_1>\>))                   # end
                    | # Or constant
                    (?:(?P<prefix_2>\()                 # begin
                        (?P<const_count>[+*?])?         # argument count.
                        (?:(?P<const_arg>%N+?)=)?       # optional argument name
                        (?P<const_options>%N+?)         # constant phrase
                        (?:\?(?P<const_name>%N+?))?     # optional helptext
                    (?P<suffix_2>\)))                   # end
                    | # Or a constant w/o parenthesis
                    (?:
                        (?P<const_count_1>[+*?])?       # argument count
                        (?:(?P<const_arg_1>%N+?)=)?     # optional argument name
                        (?P<const_options_1>%N+?)       # constant phrase
                        (?:\?(?P<const_name_1>%N+?))?   # helptext
                    )
                    | # Or anything else, which is invalid
                    (?P<error_unexpected>.+?)
                )
                (?P<suffix_3>\]*)                   # Allow any number of brackets to indicate optional sections
            )
        )
        (?:\s+|\Z)                          # Some whitespace or the end of the string
        '''.replace('%N', _paramstring_symbols), re.VERBOSE
    )

    default_type = 'str'
    type_registry = {}
    FIRST_ARG = object()
    LAST_ARG = object()

    def __init__(self, function, paramstring='', summary=None, label=None, precheck=None):
        """
        Creates a new :class:`Binding`.

        :param function: The function that we bind.
        :param paramstring: The parameter string to interpret.
        :param label: Name of this binding.  Optional.
        :param summary: Optional short summary of usage.
        :param precheck: Optional function that takes a :class:`Event` and returns True if we should even be
            considered for evaluation.
        """
        self.label = label
        self.function = function
        self.signature = inspect.signature(function)
        self.summary = summary
        self.is_default_error = False
        self.precheck = precheck or (lambda x: True)

        signature = self.signature

        kwargs_var = None
        varargs_var = None
        for data in signature.parameters.values():
            if data.kind == inspect.Parameter.VAR_KEYWORD:
                kwargs_var = data.name
            elif data.kind == inspect.Parameter.VAR_POSITIONAL:
                varargs_var = data.name

        def parse_error_here(message):
            return ParseError(message, paramstring, match.start())

        def adapt_parse_error(ex):
            if ex.message is not None or ex.pos is not None:
                raise ex
            raise parse_error_here(ex.message)

        params = []          # List of parameter structures
        self.params = params
        arg_names = set()    # Found parameter names (to avoid duplication)
        usage = []      # Usage line.  (Starts as a list, combined to a string later.)
        eol = False          # True after we've consumed a parameter that eats the remainder of the line.

        index = -1
        first_optional = None  # Index of first optional argument.
        for match in self._paramstring_re.finditer(paramstring):
            options = match.group('options')
            if options is not None:
                for ix, ch in enumerate(options):
                    if ch == 'u':
                        self.is_default_error = True
                        continue
                    raise ParseError("Unrecognized option {!r}".format(ch))
                continue
            index += 1
            if eol:
                raise parse_error_here(
                    "Previous parameter consumes remainder of line, cannot have additional parameters."
                )

            # Parse our funky regex settings
            data = collections.defaultdict(dict)
            for key, value in match.groupdict().items():
                if value is None:
                    continue
                keytype, key, *unused = key.split("_")
                data[keytype][key] = value
            prefix = "".join(v for k, v in sorted(data.pop('prefix', {}).items(), key=lambda x: int(x[0])))
            suffix = "".join(v for k, v in sorted(data.pop('suffix', {}).items(), key=lambda x: int(x[0])))
            assert len(data) == 1, "Unexpectedly matched multiple sections of paramstring."

            paramtype, data = data.popitem()  # Should only have one key left.
            if paramtype == 'error':
                error_type = next(iter(data.values()))
                raise parse_error_here({'unexpected': "Unexpected characters"}.get(error_type, error_type))

            # paramtype will be one of 'var' or 'const'
            # data will consist of:
            # arg (default to None)
            # type ('const' if paramtype == 'str', else default to 'str')
            # options (default to None)
            # name (default to arg)
            arg = data.get('arg') or None
            options = data.get('options')
            name = data.get('name')
            count = data.get('count', '')
            if paramtype == 'const':
                type_ = 'const'
                name = name or options
            else:
                type_ = data.get('type') or self.default_type
                name = name or arg

            if count and count in '+*':
                listmode = Parameter.LIST_NORMAL  # we might override this in a moment, but that's fine.
            else:
                listmode = Parameter.LIST_NONE

            required = not count or count not in '?*'
            if required and first_optional is not None:
                raise parse_error_here("Cannot have mandatory arguments after optional ones.")
            elif not required and first_optional is None:
                first_optional = index

            if arg:
                if arg in arg_names:
                    raise parse_error_here("Duplicate parameter name '{!r}'".format(arg))
                if arg == varargs_var:
                    listmode = Parameter.LIST_VARARGS
                if arg == kwargs_var:
                    raise parse_error_here("Cannot directly reference a function's kwargs argument.")
                if arg not in signature.parameters:
                    if not kwargs_var:
                        raise parse_error_here("Bound function has no argument named '{!r}'".format(arg))
                elif not listmode:
                    pass
                arg_names.add(arg)
            try:
                param = Parameter(self, index, arg, type_, options, name, listmode, required)
                eol = listmode or param.eol
                params.append(param)
            except ParseError as ex:
                raise adapt_parse_error(ex)
            usage.append(prefix + name + ("..." if listmode else "") + suffix)

        self.maxargs = None if eol else index+1
        self.minargs = index+1 if first_optional is None else first_optional
        self.usage = " ".join(usage)

    @classmethod
    def register_type(cls, class_, typename=_default, *args, **kwargs):
        """
        Registers a subclass of :class:`ParamType` as a type handler to match cases of <param:typename>

        :param class_: :class:`ParamType` subclass that will handle this type.  If None, returns a decorator.  If this
            is not a callable, it is treated as the value of 'typename' instead and a decorator is returned.
        :param typename: Name of the type
        :param args: Passed to _class's constructor after 'options'.
        :param kwargs: Passed to _class's constructor after 'options'.
        """
        if class_ is not None and not callable(class_):
            if typename is not _default:
                args = [typename] + list(args)
            typename = class_
            class_ = None

        def decorator(class_):
            if typename in cls.type_registry:
                raise ValueError("Type handler {!r} is already registered".format(typename))
            cls.type_registry[typename] = (class_, args, kwargs)
            return class_

        return decorator if class_ is None else decorator(class_)

    def bind(self, event, *args, **kwargs):
        """
        Binds the information in input_string
        :param event: An :class:`Event`
        :param args: Initial arguments to include in binding.
        :param kwargs: Initial keyword arguments to include in binding.
        :return: Outcome of signature.Bind()
        """
        if not self.precheck(event):
            raise PrecheckError()

        if len(event.arglist) < self.minargs:
            raise NotEnoughArgumentsError(None, event, self, self.params[len(event.arglist) - 1])
        if self.maxargs is not None and len(event.arglist) > self.maxargs:
            raise TooManyArgumentsError(None, event, self, None)

        param = None
        try:
            for param in self.params:
                param.validate(event)

            for param in self.params:
                param.bind(event, args, kwargs)

            param = None
            return self.signature.bind(event, *args, **kwargs)
        except UsageError as ex:
            if ex.param is None:
                ex.param = param
            if ex.binding is None:
                ex.binding = self
            raise ex

    def __call__(self, event, *args, **kwargs):
        """
        Calls the bound function.

        Equivalent to ``bound = binding.bind(...); binding.function(*bound.args, **bound.kwargs))``

        :param event: An :class:`Event` containing our arglist.
        :param args: Initial arguments to include in binding.
        :param kwargs: Initial keyword arguments to include in binding.
        :return: Result of function call.
        """
        bound = self.bind(event, *args, **kwargs)
        event.binding = self
        return self.function(*bound.args, **bound.kwargs)
register_type = Binding.register_type


class Parameter:
    LIST_NONE = 0
    LIST_NORMAL = 1
    LIST_VARARGS = 2

    def __init__(self, parent, index, arg, type_=None, options=None, name=None, listmode=LIST_NONE, required=True):
        """
        Defines a new parameter

        :param parent: Parent :class:`Binding`.
        :param index: Index in list
        :param arg: Function argument name.  May be None in some circumstances.
        :param type_: Parameter type
        :param options: Parameter type options.
        :param name: Helpname.  Defaults to 'arg' if not set.
        :param listmode: LIST_NONE(default) if this is a single argument.  LIST_NORMAL if this is a list of arguments.
            LIST_VARARGS if this is a function's args
        :param required: True if this parameter is required.  For lists, this means it must match 1+ items instead of
            0+ items.
        """
        if name is None:
            name = arg

        self.index = index
        self.parent = parent
        self.arg = arg
        self.type_ = type_
        self.options = options
        self.name = name
        self.listmode = listmode
        self.required = required

        parser_class, args, kwargs = self.parent.type_registry[self.type_]
        self.parser = parser_class(self, *args, **kwargs)
        self.eol = self.parser.eol

    def args(self, arglist):
        """
        Yields arguments from arglist that we are directly responsible for.  Helper function.

        :param arglist: A :class:`ArgumentList`
        """
        for index in range(self.index, len(arglist)):
            yield arglist[index]
            if not self.listmode:
                return

    def validate(self, event):
        """
        Performs validation of arguments in the event's `ArgumentList` that belong to us.

        Gives ParamType handlers a chance to raise a UsageError() before actually invoking the function involved.

        :param event: A :class:`Event`
        """
        if len(event.arglist) <= self.index:
            if self.required:
                if self.listmode:
                    raise UsageError("At least one {name} must be specified".format(name=self.name or '<const>'))
                raise UsageError("{name} must be specified".format(name=self.name or '<const>'))
            return
        if not self.parser.check:
            return
        for index, arg in enumerate(self.args(event.arglist), self.index):
            try:
                self.parser.validate(event, arg.eol if self.parser.eol else arg)
            except UsageError as ex:
                raise UsageError(ex.message, event.arglist, index)
            except Exception as ex:
                if self.parser.wrap_exceptions:
                    raise UsageError("Invalid format for {name}") from ex
                raise

    def bind(self, event, args, kwargs):
        """
        Updates the args and kwargs that we'll use to call the bound function based on what the ParamType handler says

        :param event: A :class:`Event`
        :param args: Initial arguments to pass to function
        :param kwargs: Additional keyword arguments to pass to function
        """
        values = []
        for index, arg in enumerate(self.args(event.arglist), self.index):
            try:
                values.append(self.parser.parse(event, arg.eol if self.parser.eol else arg))
            except UsageError as ex:
                raise UsageError(ex.message, event.arglist, index)
            except Exception as ex:
                if self.parser.wrap_exceptions:
                    raise UsageError("Invalid format for {}".format(self.name)) from ex
                raise
        if not self.arg:
            # If we don't have an argument name, we don't want to update anything.  However, it's still necessary to
            # do all of the above work in case it would throw a UsageError.
            return
        if not values:
            return
        if not self.listmode:
            kwargs[self.arg] = values[0]
            return
        if self.listmode == self.LIST_VARARGS:
            args.extend(values)
            return
        kwargs[self.arg] = values


class ParamType:
    """
    Defines logic and rules behind argument parsing.

    There's three passes to argument parsing:

    1. At bind time, a `ParamType` instance is created.  It receives any options specified as its first argument.

    2. Before calling a function, any arguments that have :attr:`check` = *True* have their validate method called.  If
       any of them raise the function will not be called and the system will continue to the next binding (if one
       exists)

    3. Before calling a function, all arguments have their :meth:`parse` method called, and the result is assigned to
       one of the function arguments.  If any of these raise, the function will not be called. and the system will
       continue to the next binding (if one exists)

    :ivar eol: If True, this argument type consumes the entire line instead of just one word.
    :ivar wrap_exceptions: If True, all non-UsageError exceptions from cls.parse() are re-raised as UsageErrors.
    :ivar check: If True, call validate() before parse().  Use this when the parsing may have side effects or
        would be otherwise expensive, but simple validation is easy.
    """
    eol = False
    wrap_exceptions = True
    check = False

    def __init__(self, param):
        """
        Created as part of the CommandBinding process.  Should raise a ParseError if invalid.

        :param param: Parameter we are attached to.
        """
        self.param = param

    def parse(self, event, value):
        """
        Parses the incoming string and returns the parsed result.

        :param event: `Event` being parsed.
        :param value: Value to parse.
        :return: Parsed result.
        """
        return value

    def validate(self, event, value):
        """
        Preparses the incoming string and raises an exception if it fails early validation.

        :param event: Event being parsed.
        :param value: Value to parse.
        :return: Nothing
        """
        return


@Binding.register_type('str')
@Binding.register_type('line', eol=True)
class StrParamType(ParamType):
    def __init__(self, param, eol=False):
        """
        String arguments are the simplest arguments, and usually return their input.

        :param param: Parameter we are bound to.

        If param.options is equal to 'lower' or 'upper', the corresponding method is called on the string before it is
        returned.
        """
        super().__init__(param)
        self.eol = eol
        if param.options and param.options in ('lower', 'upper'):
            self.parsefn = getattr(str, param.options)
        else:
            self.parsefn = str

    def parse(self, event, value):
        return self.parsefn(value)


@Binding.register_type('const')
class ConstParamType(ParamType):
    check = True

    def __init__(self, param, split=re.compile('[/|]').split):
        """
        Const arguments require that an argument be a case-insensitive exact match for one of the provided inputs.

        :param param: Parameter we are bound to.
        :param split: Function that splits constant value string into an iterable of allowed values.

        param.options dictates allowed constant values, as a string
        """
        super().__init__(param)
        self.values = set(split(param.options.lower()))
        if not self.values:
            raise ParseError("Must have at least one constant value.")

    def validate(self, event, value):
        if value not in self.values:
            if len(self.values) == 1:
                fmt = "{name} must equal {values}"
            else:
                fmt = "{name} must be one of ({values})"
            raise UsageError(fmt.format(name=self.param.name, values=", ".join(self.values)))


@Binding.register_type('int', coerce=int, coerce_error="{name} must be an integer")
@Binding.register_type('float', coerce=float, coerce_error="{name} must be a number")
class NumberParamType(ParamType):
    def __init__(self, param, coerce=int, coerce_error=None):
        """
        Number arguments require that their data be a number, potentially within a set range.

        :param param: Parameter we are bound to.
        :param coerce: Function that coerces 'min', 'max' and the input to integers.
        :param coerce_error: Error message for coercion failures.

        param.options may contain a string in the form of 'min..max' or 'min' that determines the lower and upper
        bounds for this argument.  if either 'min' or 'max' are blank (as opposed to 0), the range is treated as
        unbound at that end.
        """
        super().__init__(param)
        self.coerce = coerce
        self.coerce_error = coerce_error

        minvalue, _, maxvalue = param.options.partition('..')
        try:
            self.minvalue = coerce(minvalue) if minvalue else None
        except Exception as ex:
            raise ParseError("Unable to coerce minval using {!r}".format(coerce))

        try:
            self.maxvalue = coerce(maxvalue) if maxvalue else None
        except Exception as ex:
            raise ParseError("Unable to coerce maxval using {!r}".format(coerce))

        if self.minvalue is not None and self.maxvalue is not None and self.minvalue > self.maxvalue:
            raise ParseError("minval > maxval")

    def parse(self, event, value):
        try:
            value = self.coerce(value)
        except Exception as ex:
            if self.coerce_error:
                raise UsageError(self.coerce_error.format(name=self.param.name)) from ex
            raise

        if self.minvalue is not None and value < self.minvalue:
            if self.maxvalue is not None:
                raise UsageError(
                    "{0.param.name} must be between {0.minvalue} and {0.maxvalue}"
                    .format(self)
                )
            raise UsageError(
                "{0.param.name} must be >= {0.minvalue}"
                .format(self)
            )
        if self.maxvalue is not None and value > self.maxvalue:
            raise UsageError(
                "{0.param.name} must be <= {0.minvalue}"
                .format(self)
            )
